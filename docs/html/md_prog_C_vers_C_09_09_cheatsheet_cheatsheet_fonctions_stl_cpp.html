<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AJC Formation expert sys info - Option Data - Oct2024: Cheatsheet : Principales fonctions STL en C++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AJC Formation expert sys info - Option Data - Oct2024
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Cheatsheet : Principales fonctions STL en C++ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://en.cppreference.com/w/cpp/standard_library">https://en.cppreference.com/w/cpp/standard_library</a></p>
<h2>1. <b>std::sort</b></h2>
<p>Trie une plage d'éléments dans l'ordre croissant ou selon un critère personnalisé.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomIt&gt;</div><div class="line"><span class="keywordtype">void</span> sort(RandomIt first, RandomIt last);</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare&gt;</div><div class="line"><span class="keywordtype">void</span> sort(RandomIt first, RandomIt last, Compare comp);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li><code>std::sort</code> utilise l'algorithme "introsort", combinant quicksort, heapsort et insertion sort.</li>
<li>Trie les éléments entre les itérateurs <code>first</code> et <code>last</code> en place (sans mémoire supplémentaire).</li>
<li>Par défaut, l'ordre est croissant. Avec un comparateur, l'ordre est défini selon vos besoins.</li>
<li>Nécessite des itérateurs aléatoires (<code>std::vector</code>, <code>std::deque</code>, etc.).</li>
<li>Complexité : O(n log n).</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {5, 3, 9, 1, 4};</div><div class="line">    std::sort(v.begin(), v.end());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n : v) {</div><div class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 1 3 4 5 9</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>2. <b>std::find</b></h2>
<p>Recherche la première occurrence d'une valeur donnée dans une plage.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> T&gt;</div><div class="line">InputIt find(InputIt first, InputIt last, <span class="keyword">const</span> T&amp; value);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Cherche séquentiellement <code>value</code> dans <code>[first, last)</code>.</li>
<li>Retourne un itérateur sur la première occurrence, ou <code>last</code> si introuvable.</li>
<li>Complexité linéaire (O(n)) : examine chaque élément jusqu'à trouver la valeur ou atteindre la fin.</li>
<li>Compatible avec <code>std::vector</code>, <code>std::list</code>, <code>std::deque</code>, etc.</li>
<li>Idéal pour des recherches rapides dans des conteneurs.</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {10, 20, 30, 40, 50};</div><div class="line">    <span class="keyword">auto</span> it = std::find(v.begin(), v.end(), 30);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (it != v.end()) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Valeur trouvée à l&#39;index : &quot;</span> &lt;&lt; std::distance(v.begin(), it) &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Valeur non trouvée&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>3. <b>std::unique</b></h2>
<p>Supprime les doublons consécutifs dans une plage.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt&gt;</div><div class="line">ForwardIt unique(ForwardIt first, ForwardIt last);</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line">ForwardIt unique(ForwardIt first, ForwardIt last, BinaryPredicate p);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Réorganise les éléments pour déplacer les valeurs uniques au début de la plage.</li>
<li>Retourne un itérateur indiquant la fin logique de la plage modifiée.</li>
<li>Les doublons doivent être consécutifs, donc utiliser <code>std::sort</code> au préalable est courant.</li>
<li>Avec un prédicat binaire, vous pouvez personnaliser la logique de comparaison.</li>
<li>Complexité : O(n).</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {1, 1, 2, 3, 3, 3, 4, 4};</div><div class="line">    <span class="keyword">auto</span> it = std::unique(v.begin(), v.end());</div><div class="line">    v.erase(it, v.end());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n : v) {</div><div class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 1 2 3 4</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>4. <b>std::accumulate</b></h2>
<p>Calcule la somme (ou une accumulation personnalisée) des éléments dans une plage.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> T&gt;</div><div class="line">T accumulate(InputIt first, InputIt last, T init);</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> T, <span class="keyword">class</span> BinaryOperation&gt;</div><div class="line">T accumulate(InputIt first, InputIt last, T init, BinaryOperation op);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Additionne les éléments de <code>[first, last)</code> en commençant par <code>init</code>.</li>
<li>Retourne un résultat basé sur l'accumulation ou une opération binaire personnalisée.</li>
<li>Ne modifie pas la plage d'entrée.</li>
<li>Complexité linéaire (O(n)).</li>
<li>Utile pour des réductions comme somme, produit, ou calculs personnalisés.</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};</div><div class="line">    <span class="keywordtype">int</span> sum = std::accumulate(v.begin(), v.end(), 0);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Somme des éléments : &quot;</span> &lt;&lt; sum &lt;&lt; std::endl; <span class="comment">// 15</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>5. <b>std::count</b></h2>
<p>Compte le nombre d'occurrences d'une valeur donnée dans une plage.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIt&gt;::difference_type</div><div class="line">count(InputIt first, InputIt last, <span class="keyword">const</span> T&amp; value);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Parcourt <code>[first, last)</code> pour compter les occurrences de <code>value</code>.</li>
<li>Retourne un entier correspondant au nombre d'occurrences.</li>
<li>Complexité linéaire (O(n)).</li>
<li>Fonctionne avec tous les conteneurs itérables (<code>std::vector</code>, <code>std::list</code>, etc.).</li>
<li>Idéal pour des analyses statistiques simples.</li>
</ul>
<p>### Exemple avec une liste : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::list&lt;int&gt; lst = {1, 2, 3, 2, 4, 2};</div><div class="line">    <span class="keywordtype">int</span> count = std::count(lst.begin(), lst.end(), 2);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Le chiffre 2 apparaît &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot; fois&quot;</span> &lt;&lt; std::endl; <span class="comment">// 3</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>6. <b>std::transform</b></h2>
<p>Applique une fonction à chaque élément d'une plage et stocke les résultats.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> UnaryOperation&gt;</div><div class="line">OutputIt transform(InputIt first, InputIt last, OutputIt d_first, UnaryOperation unary_op);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Applique une fonction ou un lambda à chaque élément de <code>[first, last)</code>.</li>
<li>Stocke les résultats dans <code>[d_first, d_first + (last - first))</code>.</li>
<li>Compatible avec une ou deux plages source.</li>
<li>Complexité linéaire (O(n)).</li>
<li>Utile pour des transformations comme mise au carré, conversion en majuscules, etc.</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};</div><div class="line">    std::vector&lt;int&gt; <a class="code" href="namespaceconnexion__SSH.html#ab06475dbad7f16b89c9114749bc95254">result</a>(v.size());</div><div class="line"></div><div class="line">    std::transform(v.begin(), v.end(), result.begin(), [](<span class="keywordtype">int</span> <a class="code" href="addition_8c.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>) { <span class="keywordflow">return</span> x * <a class="code" href="addition_8c.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>; });</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n : result) {</div><div class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 1 4 9 16 25</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>7. <b>std::lower_bound</b></h2>
<p>Trouve la première position où un élément peut être inséré tout en maintenant l'ordre trié.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T&gt;</div><div class="line">ForwardIt lower_bound(ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value);</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare&gt;</div><div class="line">ForwardIt lower_bound(ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value, Compare comp);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Recherche binaire pour trouver la première position où <code>value</code> pourrait être inséré.</li>
<li>Nécessite que la plage soit triée selon l'ordre croissant ou un comparateur personnalisé.</li>
<li>Complexité logarithmique O(log n).</li>
<li>Retourne un itérateur pointant vers la position d'insertion ou vers un élément égal.</li>
<li>Utile pour des opérations d'insertion efficaces dans des conteneurs triés.</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {10, 20, 30, 40, 50};</div><div class="line">    <span class="keyword">auto</span> it = std::lower_bound(v.begin(), v.end(), 25);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Position d&#39;insertion : &quot;</span> &lt;&lt; std::distance(v.begin(), it) &lt;&lt; std::endl; <span class="comment">// 2</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>8. <b>std::upper_bound</b></h2>
<p>Trouve la première position après les éléments égaux à une valeur donnée dans une plage triée.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T&gt;</div><div class="line">ForwardIt upper_bound(ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value);</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare&gt;</div><div class="line">ForwardIt upper_bound(ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value, Compare comp);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Recherche binaire pour trouver l'itérateur pointant après le dernier élément égal à <code>value</code>.</li>
<li>Nécessite une plage triée selon l'ordre croissant ou un comparateur personnalisé.</li>
<li>Complexité logarithmique O(log n).</li>
<li>Différence principale avec <code>std::lower_bound</code> : ne retourne pas un élément égal à <code>value</code>.</li>
<li>Pratique pour des itérations sur des plages distinctes de valeurs égales.</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {10, 20, 30, 30, 50};</div><div class="line">    <span class="keyword">auto</span> it = std::upper_bound(v.begin(), v.end(), 30);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Position après les 30 : &quot;</span> &lt;&lt; std::distance(v.begin(), it) &lt;&lt; std::endl; <span class="comment">// 4</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>9. <b>std::equal</b></h2>
<p>Vérifie si deux plages sont égales.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2&gt;</div><div class="line"><span class="keywordtype">bool</span> equal(InputIt1 first1, InputIt1 last1, InputIt2 first2);</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line"><span class="keywordtype">bool</span> equal(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Compare deux plages élément par élément.</li>
<li>Retourne <code>true</code> si les plages ont les mêmes éléments dans le même ordre.</li>
<li>La version avec un prédicat permet une comparaison personnalisée.</li>
<li>La complexité est linéaire O(n), où n est la taille de la première plage.</li>
<li>Utile pour vérifier l'égalité logique ou approximative de conteneurs.</li>
</ul>
<p>### Exemple avec deux vecteurs : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v1 = {1, 2, 3};</div><div class="line">    std::vector&lt;int&gt; v2 = {1, 2, 3};</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (std::equal(v1.begin(), v1.end(), v2.begin())) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Les vecteurs sont égaux.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Les vecteurs sont différents.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>10. <b>std::mismatch</b></h2>
<p>Trouve la première position où deux plages diffèrent.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2&gt;</div><div class="line">std::pair&lt;InputIt1, InputIt2&gt; mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2);</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> BinaryPredicate&gt;</div><div class="line">std::pair&lt;InputIt1, InputIt2&gt; mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Parcourt deux plages et retourne la première paire d'itérateurs où les éléments diffèrent.</li>
<li>Si aucune différence n'est trouvée, retourne une paire avec <code>last1</code> et <code>first2 + (last1 - first1)</code>.</li>
<li>Utile pour diagnostiquer des différences entre deux conteneurs similaires.</li>
<li>La version avec prédicat permet de personnaliser la condition d'inégalité.</li>
<li>Complexité linéaire O(n).</li>
</ul>
<p>### Exemple avec deux vecteurs : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v1 = {1, 2, 3, 4};</div><div class="line">    std::vector&lt;int&gt; v2 = {1, 2, 0, 4};</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> result = std::mismatch(v1.begin(), v1.end(), v2.begin());</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (result.first != v1.end()) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Différence trouvée : &quot;</span> &lt;&lt; *result.first &lt;&lt; <span class="stringliteral">&quot; et &quot;</span> &lt;&lt; *result.second &lt;&lt; std::endl;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Aucune différence.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>11. <b>std::fill</b></h2>
<p>Remplit une plage avec une valeur donnée.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="keywordtype">void</span> fill(ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Remplace tous les éléments de la plage <code>[first, last)</code> par <code>value</code>.</li>
<li>Utile pour initialiser ou réinitialiser un conteneur.</li>
<li>Complexité linéaire O(n).</li>
<li>Fonctionne avec tous les conteneurs ayant des itérateurs modifiables.</li>
<li>Ne nécessite pas d'allocation supplémentaire.</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v(5);</div><div class="line">    std::fill(v.begin(), v.end(), 42);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n : v) {</div><div class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 42 42 42 42 42</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>12. <b>std::copy</b></h2>
<p>Copie une plage d'éléments vers une autre plage.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt&gt;</div><div class="line">OutputIt copy(InputIt first, InputIt last, OutputIt d_first);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Copie les éléments de la plage <code>[first, last)</code> vers <code>[d_first, d_first + (last - first))</code>.</li>
<li>Utile pour dupliquer des conteneurs ou une partie d'eux.</li>
<li>Complexité linéaire O(n).</li>
<li>La plage de destination doit avoir suffisamment d'espace alloué pour éviter des comportements indéfinis.</li>
<li>Si les plages se chevauchent, utiliser <code>std::copy_backward</code>.</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; src = {1, 2, 3};</div><div class="line">    std::vector&lt;int&gt; dest(3);</div><div class="line"></div><div class="line">    std::copy(src.begin(), src.end(), dest.begin());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n : dest) {</div><div class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 1 2 3</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>13. <b>std::set_intersection</b></h2>
<p>Calcule l'intersection de deux plages triées.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> OutputIt&gt;</div><div class="line">OutputIt set_intersection(InputIt1 first1, InputIt1 last1,</div><div class="line">                          InputIt2 first2, InputIt2 last2,</div><div class="line">                          OutputIt d_first);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Nécessite que les deux plages soient triées.</li>
<li>Retourne une plage contenant les éléments communs aux deux plages.</li>
<li>Complexité linéaire O(n), où n est la somme des tailles des plages.</li>
<li>Utile pour des opérations sur des ensembles triés.</li>
<li>Si une version personnalisée de comparaison est nécessaire, fournir une fonction <code>Compare</code>.</li>
</ul>
<p>### Exemple avec deux vecteurs : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v1 = {1, 2, 3, 4};</div><div class="line">    std::vector&lt;int&gt; v2 = {3, 4, 5, 6};</div><div class="line">    std::vector&lt;int&gt; <a class="code" href="namespaceconnexion__SSH.html#ab06475dbad7f16b89c9114749bc95254">result</a>;</div><div class="line"></div><div class="line">    std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(),</div><div class="line">                          std::back_inserter(result));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n : result) {</div><div class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 3 4</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>14. <b>std::set_union</b></h2>
<p>Calcule l'union de deux plages triées.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> OutputIt&gt;</div><div class="line">OutputIt set_union(InputIt1 first1, InputIt1 last1,</div><div class="line">                   InputIt2 first2, InputIt2 last2,</div><div class="line">                   OutputIt d_first);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Combine deux plages triées en une seule, contenant tous les éléments (sans doublons).</li>
<li>Nécessite que les plages soient triées.</li>
<li>Complexité linéaire O(n).</li>
<li>Utile pour travailler avec des ensembles triés.</li>
</ul>
<p>### Exemple avec deux vecteurs : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v1 = {1, 2, 3, 4};</div><div class="line">    std::vector&lt;int&gt; v2 = {3, 4, 5, 6};</div><div class="line">    std::vector&lt;int&gt; <a class="code" href="namespaceconnexion__SSH.html#ab06475dbad7f16b89c9114749bc95254">result</a>;</div><div class="line"></div><div class="line">    std::set_union(v1.begin(), v1.end(), v2.begin(), v2.end(),</div><div class="line">                   std::back_inserter(result));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n : result) {</div><div class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 1 2 3 4 5 6</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>15. <b>std::remove</b></h2>
<p>Supprime des éléments spécifiques d'une plage (logiquement).</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T&gt;</div><div class="line">ForwardIt <span class="keyword">remove</span>(ForwardIt first, ForwardIt last, <span class="keyword">const</span> T&amp; value);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Réorganise les éléments pour déplacer ceux qui ne correspondent pas à <code>value</code> vers le début.</li>
<li>Retourne un itérateur à la nouvelle fin logique.</li>
<li>Pour supprimer physiquement les éléments, utilisez <code>erase</code> du conteneur.</li>
<li>Complexité linéaire O(n).</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {1, 2, 3, 2, 4};</div><div class="line">    <span class="keyword">auto</span> it = std::remove(v.begin(), v.end(), 2);</div><div class="line">    v.erase(it, v.end());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n : v) {</div><div class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 1 3 4</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>16. <b>std::find_if</b></h2>
<p>Trouve le premier élément correspondant à une condition.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> UnaryPredicate&gt;</div><div class="line">InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Parcourt <code>[first, last)</code> pour trouver le premier élément satisfaisant la condition <code>p</code>.</li>
<li>Retourne <code>last</code> si aucun élément ne correspond.</li>
<li>Utile pour des recherches conditionnelles.</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {1, 3, 5, 8, 9};</div><div class="line">    <span class="keyword">auto</span> it = std::find_if(v.begin(), v.end(), [](<span class="keywordtype">int</span> <a class="code" href="addition_8c.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>) { <span class="keywordflow">return</span> x % 2 == 0; });</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (it != v.end()) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Premier nombre pair : &quot;</span> &lt;&lt; *it &lt;&lt; std::endl; <span class="comment">// 8</span></div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Aucun nombre pair trouvé.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>17. <b>std::generate</b></h2>
<p>Remplit une plage avec des valeurs générées par une fonction.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> Generator&gt;</div><div class="line"><span class="keywordtype">void</span> generate(ForwardIt first, ForwardIt last, Generator g);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Applique la fonction <code>g</code> pour remplir chaque élément dans <code>[first, last)</code>.</li>
<li>Utile pour initialiser des conteneurs avec des valeurs calculées dynamiquement.</li>
<li>Complexité linéaire O(n).</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v(5);</div><div class="line">    <span class="keywordtype">int</span> n = 0;</div><div class="line">    std::generate(v.begin(), v.end(), [&amp;<a class="code" href="exo21_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>]() { <span class="keywordflow">return</span> n++; });</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x : v) {</div><div class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 0 1 2 3 4</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>18. <b>std::partition</b></h2>
<p>Réorganise une plage pour séparer les éléments selon une condition.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> B<span class="keywordtype">id</span>irectionalIt, <span class="keyword">class</span> UnaryPredicate&gt;</div><div class="line">BidirectionalIt partition(BidirectionalIt first, BidirectionalIt last, UnaryPredicate p);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Place tous les éléments satisfaisant <code>p</code> avant ceux qui ne le satisfont pas.</li>
<li>Retourne un itérateur à la fin des éléments satisfaisant <code>p</code>.</li>
<li>Complexité linéaire O(n).</li>
<li>Utile pour regrouper des éléments selon des critères.</li>
</ul>
<p>### Exemple avec un vecteur : </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};</div><div class="line">    <span class="keyword">auto</span> it = std::partition(v.begin(), v.end(), [](<span class="keywordtype">int</span> <a class="code" href="addition_8c.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>) { <span class="keywordflow">return</span> x % 2 == 0; });</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n : v) {</div><div class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// 2 4 1 3 5</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <hr/>
<h2>19. <b>std::nth_element</b></h2>
<p>Réorganise les éléments pour qu'un élément soit à sa position finale triée.</p>
<p>### Prototype : </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomIt&gt;</div><div class="line"><span class="keywordtype">void</span> nth_element(RandomIt first, RandomIt nth, RandomIt last);</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare&gt;</div><div class="line"><span class="keywordtype">void</span> nth_element(RandomIt first, RandomIt nth, RandomIt last, Compare comp);</div></div><!-- fragment --><h3>Explications détaillées :</h3>
<ul>
<li>Après exécution, l'élément pointé par <code>nth</code> est à sa position finale si la plage était triée.</li>
<li>Les éléments avant sont inférieurs, et ceux après sont supérieurs (non triés).</li>
<li>Complexité moyenne O(n).</li>
<li>Utile pour trouver rapidement le k-ième plus petit élément.</li>
</ul>
<h3>Exemple avec un vecteur :</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="htop_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div><div class="line">    std::vector&lt;int&gt; v = {3, 1, 4, 1, 5, 9, 2};</div><div class="line">    std::nth_element(v.begin(), v.begin() + 3, v.end());</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Élément à la position 3 : &quot;</span> &lt;&lt; v[3] &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
