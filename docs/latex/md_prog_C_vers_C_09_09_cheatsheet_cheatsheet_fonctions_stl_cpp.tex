\href{https://en.cppreference.com/w/cpp/standard_library}{\tt https\+://en.\+cppreference.\+com/w/cpp/standard\+\_\+library}

\subsection*{1. {\bfseries std\+::sort}}

Trie une plage d\textquotesingle{}éléments dans l\textquotesingle{}ordre croissant ou selon un critère personnalisé.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} RandomIt>
\textcolor{keywordtype}{void} sort(RandomIt first, RandomIt last);
\textcolor{keyword}{template}<\textcolor{keyword}{class} RandomIt, \textcolor{keyword}{class} Compare>
\textcolor{keywordtype}{void} sort(RandomIt first, RandomIt last, Compare comp);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item {\ttfamily std\+::sort} utilise l\textquotesingle{}algorithme \char`\"{}introsort\char`\"{}, combinant quicksort, heapsort et insertion sort.
\item Trie les éléments entre les itérateurs {\ttfamily first} et {\ttfamily last} en place (sans mémoire supplémentaire).
\item Par défaut, l\textquotesingle{}ordre est croissant. Avec un comparateur, l\textquotesingle{}ordre est défini selon vos besoins.
\item Nécessite des itérateurs aléatoires ({\ttfamily std\+::vector}, {\ttfamily std\+::deque}, etc.).
\item Complexité \+: O(n log n).
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{5, 3, 9, 1, 4\};
    std::sort(v.begin(), v.end());

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n : v) \{
        std::cout << n << \textcolor{stringliteral}{" "}; \textcolor{comment}{// 1 3 4 5 9}
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{2. {\bfseries std\+::find}}

Recherche la première occurrence d\textquotesingle{}une valeur donnée dans une plage.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt, \textcolor{keyword}{class} T>
InputIt find(InputIt first, InputIt last, \textcolor{keyword}{const} T& value);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Cherche séquentiellement {\ttfamily value} dans {\ttfamily \mbox{[}first, last)}.
\item Retourne un itérateur sur la première occurrence, ou {\ttfamily last} si introuvable.
\item Complexité linéaire (O(n)) \+: examine chaque élément jusqu\textquotesingle{}à trouver la valeur ou atteindre la fin.
\item Compatible avec {\ttfamily std\+::vector}, {\ttfamily std\+::list}, {\ttfamily std\+::deque}, etc.
\item Idéal pour des recherches rapides dans des conteneurs.
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{10, 20, 30, 40, 50\};
    \textcolor{keyword}{auto} it = std::find(v.begin(), v.end(), 30);

    \textcolor{keywordflow}{if} (it != v.end()) \{
        std::cout << \textcolor{stringliteral}{"Valeur trouvée à l'index : "} << std::distance(v.begin(), it) << std::endl;
    \} \textcolor{keywordflow}{else} \{
        std::cout << \textcolor{stringliteral}{"Valeur non trouvée"} << std::endl;
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{3. {\bfseries std\+::unique}}

Supprime les doublons consécutifs dans une plage.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ForwardIt>
ForwardIt unique(ForwardIt first, ForwardIt last);
\textcolor{keyword}{template}<\textcolor{keyword}{class} ForwardIt, \textcolor{keyword}{class} BinaryPredicate>
ForwardIt unique(ForwardIt first, ForwardIt last, BinaryPredicate p);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Réorganise les éléments pour déplacer les valeurs uniques au début de la plage.
\item Retourne un itérateur indiquant la fin logique de la plage modifiée.
\item Les doublons doivent être consécutifs, donc utiliser {\ttfamily std\+::sort} au préalable est courant.
\item Avec un prédicat binaire, vous pouvez personnaliser la logique de comparaison.
\item Complexité \+: O(n).
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{1, 1, 2, 3, 3, 3, 4, 4\};
    \textcolor{keyword}{auto} it = std::unique(v.begin(), v.end());
    v.erase(it, v.end());

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n : v) \{
        std::cout << n << \textcolor{stringliteral}{" "}; \textcolor{comment}{// 1 2 3 4}
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{4. {\bfseries std\+::accumulate}}

Calcule la somme (ou une accumulation personnalisée) des éléments dans une plage.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt, \textcolor{keyword}{class} T>
T accumulate(InputIt first, InputIt last, T init);
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt, \textcolor{keyword}{class} T, \textcolor{keyword}{class} BinaryOperation>
T accumulate(InputIt first, InputIt last, T init, BinaryOperation op);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Additionne les éléments de {\ttfamily \mbox{[}first, last)} en commençant par {\ttfamily init}.
\item Retourne un résultat basé sur l\textquotesingle{}accumulation ou une opération binaire personnalisée.
\item Ne modifie pas la plage d\textquotesingle{}entrée.
\item Complexité linéaire (O(n)).
\item Utile pour des réductions comme somme, produit, ou calculs personnalisés.
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <numeric>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{1, 2, 3, 4, 5\};
    \textcolor{keywordtype}{int} sum = std::accumulate(v.begin(), v.end(), 0);

    std::cout << \textcolor{stringliteral}{"Somme des éléments : "} << sum << std::endl; \textcolor{comment}{// 15}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{5. {\bfseries std\+::count}}

Compte le nombre d\textquotesingle{}occurrences d\textquotesingle{}une valeur donnée dans une plage.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt, \textcolor{keyword}{class} T>
\textcolor{keyword}{typename} iterator\_traits<InputIt>::difference\_type
count(InputIt first, InputIt last, \textcolor{keyword}{const} T& value);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Parcourt {\ttfamily \mbox{[}first, last)} pour compter les occurrences de {\ttfamily value}.
\item Retourne un entier correspondant au nombre d\textquotesingle{}occurrences.
\item Complexité linéaire (O(n)).
\item Fonctionne avec tous les conteneurs itérables ({\ttfamily std\+::vector}, {\ttfamily std\+::list}, etc.).
\item Idéal pour des analyses statistiques simples.
\end{DoxyItemize}

\#\#\# Exemple avec une liste \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <list>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::list<int> lst = \{1, 2, 3, 2, 4, 2\};
    \textcolor{keywordtype}{int} count = std::count(lst.begin(), lst.end(), 2);

    std::cout << \textcolor{stringliteral}{"Le chiffre 2 apparaît "} << count << \textcolor{stringliteral}{" fois"} << std::endl; \textcolor{comment}{// 3}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{6. {\bfseries std\+::transform}}

Applique une fonction à chaque élément d\textquotesingle{}une plage et stocke les résultats.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt, \textcolor{keyword}{class} OutputIt, \textcolor{keyword}{class} UnaryOperation>
OutputIt transform(InputIt first, InputIt last, OutputIt d\_first, UnaryOperation unary\_op);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Applique une fonction ou un lambda à chaque élément de {\ttfamily \mbox{[}first, last)}.
\item Stocke les résultats dans {\ttfamily \mbox{[}d\+\_\+first, d\+\_\+first + (last -\/ first))}.
\item Compatible avec une ou deux plages source.
\item Complexité linéaire (O(n)).
\item Utile pour des transformations comme mise au carré, conversion en majuscules, etc.
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{1, 2, 3, 4, 5\};
    std::vector<int> \hyperlink{namespaceconnexion__SSH_ab06475dbad7f16b89c9114749bc95254}{result}(v.size());

    std::transform(v.begin(), v.end(), result.begin(), [](\textcolor{keywordtype}{int} \hyperlink{addition_8c_a6150e0515f7202e2fb518f7206ed97dc}{x}) \{ \textcolor{keywordflow}{return} x * \hyperlink{addition_8c_a6150e0515f7202e2fb518f7206ed97dc}{x}; \});

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n : result) \{
        std::cout << n << \textcolor{stringliteral}{" "}; \textcolor{comment}{// 1 4 9 16 25}
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{7. {\bfseries std\+::lower\+\_\+bound}}

Trouve la première position où un élément peut être inséré tout en maintenant l\textquotesingle{}ordre trié.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ForwardIt, \textcolor{keyword}{class} T>
ForwardIt lower\_bound(ForwardIt first, ForwardIt last, \textcolor{keyword}{const} T& value);
\textcolor{keyword}{template}<\textcolor{keyword}{class} ForwardIt, \textcolor{keyword}{class} T, \textcolor{keyword}{class} Compare>
ForwardIt lower\_bound(ForwardIt first, ForwardIt last, \textcolor{keyword}{const} T& value, Compare comp);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Recherche binaire pour trouver la première position où {\ttfamily value} pourrait être inséré.
\item Nécessite que la plage soit triée selon l\textquotesingle{}ordre croissant ou un comparateur personnalisé.
\item Complexité logarithmique O(log n).
\item Retourne un itérateur pointant vers la position d\textquotesingle{}insertion ou vers un élément égal.
\item Utile pour des opérations d\textquotesingle{}insertion efficaces dans des conteneurs triés.
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{10, 20, 30, 40, 50\};
    \textcolor{keyword}{auto} it = std::lower\_bound(v.begin(), v.end(), 25);

    std::cout << \textcolor{stringliteral}{"Position d'insertion : "} << std::distance(v.begin(), it) << std::endl; \textcolor{comment}{// 2}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{8. {\bfseries std\+::upper\+\_\+bound}}

Trouve la première position après les éléments égaux à une valeur donnée dans une plage triée.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ForwardIt, \textcolor{keyword}{class} T>
ForwardIt upper\_bound(ForwardIt first, ForwardIt last, \textcolor{keyword}{const} T& value);
\textcolor{keyword}{template}<\textcolor{keyword}{class} ForwardIt, \textcolor{keyword}{class} T, \textcolor{keyword}{class} Compare>
ForwardIt upper\_bound(ForwardIt first, ForwardIt last, \textcolor{keyword}{const} T& value, Compare comp);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Recherche binaire pour trouver l\textquotesingle{}itérateur pointant après le dernier élément égal à {\ttfamily value}.
\item Nécessite une plage triée selon l\textquotesingle{}ordre croissant ou un comparateur personnalisé.
\item Complexité logarithmique O(log n).
\item Différence principale avec {\ttfamily std\+::lower\+\_\+bound} \+: ne retourne pas un élément égal à {\ttfamily value}.
\item Pratique pour des itérations sur des plages distinctes de valeurs égales.
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{10, 20, 30, 30, 50\};
    \textcolor{keyword}{auto} it = std::upper\_bound(v.begin(), v.end(), 30);

    std::cout << \textcolor{stringliteral}{"Position après les 30 : "} << std::distance(v.begin(), it) << std::endl; \textcolor{comment}{// 4}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{9. {\bfseries std\+::equal}}

Vérifie si deux plages sont égales.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt1, \textcolor{keyword}{class} InputIt2>
\textcolor{keywordtype}{bool} equal(InputIt1 first1, InputIt1 last1, InputIt2 first2);
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt1, \textcolor{keyword}{class} InputIt2, \textcolor{keyword}{class} BinaryPredicate>
\textcolor{keywordtype}{bool} equal(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Compare deux plages élément par élément.
\item Retourne {\ttfamily true} si les plages ont les mêmes éléments dans le même ordre.
\item La version avec un prédicat permet une comparaison personnalisée.
\item La complexité est linéaire O(n), où n est la taille de la première plage.
\item Utile pour vérifier l\textquotesingle{}égalité logique ou approximative de conteneurs.
\end{DoxyItemize}

\#\#\# Exemple avec deux vecteurs \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v1 = \{1, 2, 3\};
    std::vector<int> v2 = \{1, 2, 3\};

    \textcolor{keywordflow}{if} (std::equal(v1.begin(), v1.end(), v2.begin())) \{
        std::cout << \textcolor{stringliteral}{"Les vecteurs sont égaux."} << std::endl;
    \} \textcolor{keywordflow}{else} \{
        std::cout << \textcolor{stringliteral}{"Les vecteurs sont différents."} << std::endl;
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{10. {\bfseries std\+::mismatch}}

Trouve la première position où deux plages diffèrent.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt1, \textcolor{keyword}{class} InputIt2>
std::pair<InputIt1, InputIt2> mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2);
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt1, \textcolor{keyword}{class} InputIt2, \textcolor{keyword}{class} BinaryPredicate>
std::pair<InputIt1, InputIt2> mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPredicate p)
      ;
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Parcourt deux plages et retourne la première paire d\textquotesingle{}itérateurs où les éléments diffèrent.
\item Si aucune différence n\textquotesingle{}est trouvée, retourne une paire avec {\ttfamily last1} et {\ttfamily first2 + (last1 -\/ first1)}.
\item Utile pour diagnostiquer des différences entre deux conteneurs similaires.
\item La version avec prédicat permet de personnaliser la condition d\textquotesingle{}inégalité.
\item Complexité linéaire O(n).
\end{DoxyItemize}

\#\#\# Exemple avec deux vecteurs \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v1 = \{1, 2, 3, 4\};
    std::vector<int> v2 = \{1, 2, 0, 4\};

    \textcolor{keyword}{auto} result = std::mismatch(v1.begin(), v1.end(), v2.begin());

    \textcolor{keywordflow}{if} (result.first != v1.end()) \{
        std::cout << \textcolor{stringliteral}{"Différence trouvée : "} << *result.first << \textcolor{stringliteral}{" et "} << *result.second << std::endl;
    \} \textcolor{keywordflow}{else} \{
        std::cout << \textcolor{stringliteral}{"Aucune différence."} << std::endl;
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{11. {\bfseries std\+::fill}}

Remplit une plage avec une valeur donnée.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ForwardIt, \textcolor{keyword}{class} T>
\textcolor{keywordtype}{void} fill(ForwardIt first, ForwardIt last, \textcolor{keyword}{const} T& value);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Remplace tous les éléments de la plage {\ttfamily \mbox{[}first, last)} par {\ttfamily value}.
\item Utile pour initialiser ou réinitialiser un conteneur.
\item Complexité linéaire O(n).
\item Fonctionne avec tous les conteneurs ayant des itérateurs modifiables.
\item Ne nécessite pas d\textquotesingle{}allocation supplémentaire.
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v(5);
    std::fill(v.begin(), v.end(), 42);

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n : v) \{
        std::cout << n << \textcolor{stringliteral}{" "}; \textcolor{comment}{// 42 42 42 42 42}
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{12. {\bfseries std\+::copy}}

Copie une plage d\textquotesingle{}éléments vers une autre plage.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt, \textcolor{keyword}{class} OutputIt>
OutputIt copy(InputIt first, InputIt last, OutputIt d\_first);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Copie les éléments de la plage {\ttfamily \mbox{[}first, last)} vers {\ttfamily \mbox{[}d\+\_\+first, d\+\_\+first + (last -\/ first))}.
\item Utile pour dupliquer des conteneurs ou une partie d\textquotesingle{}eux.
\item Complexité linéaire O(n).
\item La plage de destination doit avoir suffisamment d\textquotesingle{}espace alloué pour éviter des comportements indéfinis.
\item Si les plages se chevauchent, utiliser {\ttfamily std\+::copy\+\_\+backward}.
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> src = \{1, 2, 3\};
    std::vector<int> dest(3);

    std::copy(src.begin(), src.end(), dest.begin());

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n : dest) \{
        std::cout << n << \textcolor{stringliteral}{" "}; \textcolor{comment}{// 1 2 3}
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{13. {\bfseries std\+::set\+\_\+intersection}}

Calcule l\textquotesingle{}intersection de deux plages triées.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt1, \textcolor{keyword}{class} InputIt2, \textcolor{keyword}{class} OutputIt>
OutputIt set\_intersection(InputIt1 first1, InputIt1 last1,
                          InputIt2 first2, InputIt2 last2,
                          OutputIt d\_first);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Nécessite que les deux plages soient triées.
\item Retourne une plage contenant les éléments communs aux deux plages.
\item Complexité linéaire O(n), où n est la somme des tailles des plages.
\item Utile pour des opérations sur des ensembles triés.
\item Si une version personnalisée de comparaison est nécessaire, fournir une fonction {\ttfamily Compare}.
\end{DoxyItemize}

\#\#\# Exemple avec deux vecteurs \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v1 = \{1, 2, 3, 4\};
    std::vector<int> v2 = \{3, 4, 5, 6\};
    std::vector<int> \hyperlink{namespaceconnexion__SSH_ab06475dbad7f16b89c9114749bc95254}{result};

    std::set\_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(),
                          std::back\_inserter(result));

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n : result) \{
        std::cout << n << \textcolor{stringliteral}{" "}; \textcolor{comment}{// 3 4}
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{14. {\bfseries std\+::set\+\_\+union}}

Calcule l\textquotesingle{}union de deux plages triées.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt1, \textcolor{keyword}{class} InputIt2, \textcolor{keyword}{class} OutputIt>
OutputIt set\_union(InputIt1 first1, InputIt1 last1,
                   InputIt2 first2, InputIt2 last2,
                   OutputIt d\_first);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Combine deux plages triées en une seule, contenant tous les éléments (sans doublons).
\item Nécessite que les plages soient triées.
\item Complexité linéaire O(n).
\item Utile pour travailler avec des ensembles triés.
\end{DoxyItemize}

\#\#\# Exemple avec deux vecteurs \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v1 = \{1, 2, 3, 4\};
    std::vector<int> v2 = \{3, 4, 5, 6\};
    std::vector<int> \hyperlink{namespaceconnexion__SSH_ab06475dbad7f16b89c9114749bc95254}{result};

    std::set\_union(v1.begin(), v1.end(), v2.begin(), v2.end(),
                   std::back\_inserter(result));

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n : result) \{
        std::cout << n << \textcolor{stringliteral}{" "}; \textcolor{comment}{// 1 2 3 4 5 6}
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{15. {\bfseries std\+::remove}}

Supprime des éléments spécifiques d\textquotesingle{}une plage (logiquement).

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ForwardIt, \textcolor{keyword}{class} T>
ForwardIt \textcolor{keyword}{remove}(ForwardIt first, ForwardIt last, \textcolor{keyword}{const} T& value);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Réorganise les éléments pour déplacer ceux qui ne correspondent pas à {\ttfamily value} vers le début.
\item Retourne un itérateur à la nouvelle fin logique.
\item Pour supprimer physiquement les éléments, utilisez {\ttfamily erase} du conteneur.
\item Complexité linéaire O(n).
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{1, 2, 3, 2, 4\};
    \textcolor{keyword}{auto} it = std::remove(v.begin(), v.end(), 2);
    v.erase(it, v.end());

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n : v) \{
        std::cout << n << \textcolor{stringliteral}{" "}; \textcolor{comment}{// 1 3 4}
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{16. {\bfseries std\+::find\+\_\+if}}

Trouve le premier élément correspondant à une condition.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} InputIt, \textcolor{keyword}{class} UnaryPredicate>
InputIt find\_if(InputIt first, InputIt last, UnaryPredicate p);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Parcourt {\ttfamily \mbox{[}first, last)} pour trouver le premier élément satisfaisant la condition {\ttfamily p}.
\item Retourne {\ttfamily last} si aucun élément ne correspond.
\item Utile pour des recherches conditionnelles.
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{1, 3, 5, 8, 9\};
    \textcolor{keyword}{auto} it = std::find\_if(v.begin(), v.end(), [](\textcolor{keywordtype}{int} \hyperlink{addition_8c_a6150e0515f7202e2fb518f7206ed97dc}{x}) \{ \textcolor{keywordflow}{return} x % 2 == 0; \});

    \textcolor{keywordflow}{if} (it != v.end()) \{
        std::cout << \textcolor{stringliteral}{"Premier nombre pair : "} << *it << std::endl; \textcolor{comment}{// 8}
    \} \textcolor{keywordflow}{else} \{
        std::cout << \textcolor{stringliteral}{"Aucun nombre pair trouvé."} << std::endl;
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{17. {\bfseries std\+::generate}}

Remplit une plage avec des valeurs générées par une fonction.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ForwardIt, \textcolor{keyword}{class} Generator>
\textcolor{keywordtype}{void} generate(ForwardIt first, ForwardIt last, Generator g);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Applique la fonction {\ttfamily g} pour remplir chaque élément dans {\ttfamily \mbox{[}first, last)}.
\item Utile pour initialiser des conteneurs avec des valeurs calculées dynamiquement.
\item Complexité linéaire O(n).
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v(5);
    \textcolor{keywordtype}{int} n = 0;
    std::generate(v.begin(), v.end(), [&\hyperlink{exo21_8cpp_a76f11d9a0a47b94f72c2d0e77fb32240}{n}]() \{ \textcolor{keywordflow}{return} n++; \});

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} x : v) \{
        std::cout << x << \textcolor{stringliteral}{" "}; \textcolor{comment}{// 0 1 2 3 4}
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{18. {\bfseries std\+::partition}}

Réorganise une plage pour séparer les éléments selon une condition.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} B\textcolor{keywordtype}{id}irectionalIt, \textcolor{keyword}{class} UnaryPredicate>
BidirectionalIt partition(BidirectionalIt first, BidirectionalIt last, UnaryPredicate p);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Place tous les éléments satisfaisant {\ttfamily p} avant ceux qui ne le satisfont pas.
\item Retourne un itérateur à la fin des éléments satisfaisant {\ttfamily p}.
\item Complexité linéaire O(n).
\item Utile pour regrouper des éléments selon des critères.
\end{DoxyItemize}

\#\#\# Exemple avec un vecteur \+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{1, 2, 3, 4, 5\};
    \textcolor{keyword}{auto} it = std::partition(v.begin(), v.end(), [](\textcolor{keywordtype}{int} \hyperlink{addition_8c_a6150e0515f7202e2fb518f7206ed97dc}{x}) \{ \textcolor{keywordflow}{return} x % 2 == 0; \});

    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n : v) \{
        std::cout << n << \textcolor{stringliteral}{" "}; \textcolor{comment}{// 2 4 1 3 5}
    \}
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 



\subsection*{19. {\bfseries std\+::nth\+\_\+element}}

Réorganise les éléments pour qu\textquotesingle{}un élément soit à sa position finale triée.

\#\#\# Prototype \+: 
\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} RandomIt>
\textcolor{keywordtype}{void} nth\_element(RandomIt first, RandomIt nth, RandomIt last);
\textcolor{keyword}{template}<\textcolor{keyword}{class} RandomIt, \textcolor{keyword}{class} Compare>
\textcolor{keywordtype}{void} nth\_element(RandomIt first, RandomIt nth, RandomIt last, Compare comp);
\end{DoxyCode}


\subsubsection*{Explications détaillées \+:}


\begin{DoxyItemize}
\item Après exécution, l\textquotesingle{}élément pointé par {\ttfamily nth} est à sa position finale si la plage était triée.
\item Les éléments avant sont inférieurs, et ceux après sont supérieurs (non triés).
\item Complexité moyenne O(n).
\item Utile pour trouver rapidement le k-\/ième plus petit élément.
\end{DoxyItemize}

\subsubsection*{Exemple avec un vecteur \+:}


\begin{DoxyCode}
\textcolor{preprocessor}{#include <algorithm>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <iostream>}

\textcolor{keywordtype}{int} \hyperlink{htop_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main}() \{
    std::vector<int> v = \{3, 1, 4, 1, 5, 9, 2\};
    std::nth\_element(v.begin(), v.begin() + 3, v.end());

    std::cout << \textcolor{stringliteral}{"Élément à la position 3 : "} << v[3] << std::endl;
    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}
 