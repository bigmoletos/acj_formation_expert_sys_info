\subsection*{Naming conventions }

Names are important to convey what all those things inside the project are for. Filenames for source code traditionally used camel-\/case naming with the first letter written in uppercase. The file extension is always lowercase.

The only exceptions here are {\ttfamily \hyperlink{htop_8c}{htop.\+c}} and {\ttfamily \hyperlink{pcp-htop_8c}{pcp-\/htop.\+c}}, which contain the main entrance points into the code.

Folders for e.\+g. platform-\/specific code or complex features spawning multiple files are written in lowercase, e.\+g. {\ttfamily linux}, {\ttfamily freebsd}, {\ttfamily zfs}.

Inside files, the naming somewhat depends on the context. Function names should include a camel-\/case prefix before the actual name, separated by an underscore. While this prefix usually coincides with the module name, this is not required, yet strongly advised. One important exception to this rule are the memory management and the string utility functions from {\ttfamily \hyperlink{XUtils_8h}{X\+Utils.\+h}}.

Variable names inside functions should be short and precise. Using {\ttfamily i} for some loop counter is totally fine, using {\ttfamily some\+Counter\+Value\+For\+This\+Simple\+Loop} is not. On the other hand, when you need to hold global storage try to keep this local to your module, i.\+e. declare such variables {\ttfamily static} within the C source file. Only if your variable really needs to be visible for the whole project (which is really rare) it deserves a declaration in the header, marked {\ttfamily extern}.

\subsection*{File content structure }

The content within each file is usually structured according to the following loose template\+:


\begin{DoxyItemize}
\item Copyright declaration
\item Inclusion of used headers
\item Necessary data structures and forward declarations
\item Static module-\/private function implementations
\item Externally visible function implementations
\item Externally visible constant structures (pseudo-\/\+O\+OP definitions)
\end{DoxyItemize}

For header files header guards based on {\ttfamily \#ifdef} should be used. These header guards are historically placed {\bfseries before} the Copyright declaration. Stick to that for consistency please.

Example\+:


\begin{DoxyCode}
\textcolor{preprocessor}{#ifndef HEADER\_FILENAME}
\textcolor{preprocessor}{#define HEADER\_FILENAME}
\textcolor{comment}{/*}
\textcolor{comment}{htop - Filename.h}
\textcolor{comment}{(C) 2021 htop dev team}
\textcolor{comment}{Released under the GNU GPLv2+, see the COPYING file}
\textcolor{comment}{in the source distribution for its full text.}
\textcolor{comment}{*/}
\end{DoxyCode}


\subsection*{Import and use of headers }

We use the G\+P\+Lv2+ as a shorthand indication that we release {\ttfamily htop} under the G\+NU Public license version 2 but are totally fine with users opting to apply the \char`\"{}any later version\char`\"{} clause.

Every file should import headers for all symbols it\textquotesingle{}s using. Thus when using a symbol from a header, even if that symbol is already imported by something else you use, you should declare an import for that header. Doing so allows for easier restructuring of the code when things need to be moved around. If you are unsure if all necessary headers are included you might use I\+W\+YU to tell you.

The list of includes should be the first thing in the file, after the copyright comment and be followed by two blank lines. The include list should be in the following order, with each group separated by one blank line\+:


\begin{DoxyEnumerate}
\item {\ttfamily include \char`\"{}config.\+h\char`\"{} // I\+W\+YU pragma\+: keep} if the global configuration from {\ttfamily automake}\&{\ttfamily autoconfigure} or any of the feature guards for C library headers (like {\ttfamily \+\_\+\+\_\+\+G\+N\+U\+\_\+\+S\+O\+U\+R\+CE}) are required, optional otherwise. Beware of the I\+W\+YU comment.
\item Accompanying module header file (for C source files only, missing inside headers)
\item List of used system headers (non-\/conditional includes)
\item List of used program headers
\item Conditionally included header files, system headers first
\end{DoxyEnumerate}

The list of headers should be sorted with includes from subdirectories following after files inside their parent directory. Thus {\ttfamily unistd.\+h} sorts before {\ttfamily sys/time.\+h}.

When {\ttfamily \hyperlink{XUtils_8h}{X\+Utils.\+h}} is used by the module itself or any of its included headers, the C source file must include {\ttfamily config.\+h} in the manner noted above. Failure to do so will cause a compilation error (sanity check inside {\ttfamily \hyperlink{XUtils_8h}{X\+Utils.\+h}}) or may result in other, hard-\/to-\/debug compilation issues. The include for {\ttfamily config.\+h} is only ever placed in the C source file and never in any header file. For further details see PR \#1337 in our issue tracker.

\subsection*{Symbol Exports }

Exports of symbols should be used sparingly. Thus unless a function you write is intended to become public A\+PI of a module you should mark it as {\ttfamily static}. If a function should be public A\+PI an appropriate declaration for that function has to be placed in the accompanying header file.

Please avoid function-\/like macros, in particular when exporting them in a header file. They have several downsides (re-\/evaluation of arguments, syntactic escapes, weak typing) for which usually a better alternative like an actual function exists. Furthermore when using function-\/like {\ttfamily define}s you may need to mark certain headers for I\+W\+YU so tracking of used symbols works.

\subsection*{Memory Management }

When allocating memory make sure to free resources properly. For allocation this project uses a set of tiny wrappers around the common functions {\ttfamily malloc}, {\ttfamily calloc} and {\ttfamily realloc} named {\ttfamily x\+Malloc}, {\ttfamily x\+Calloc} and {\ttfamily x\+Realloc}. These functions check that memory allocation worked and error out on failure.

Allocation functions assert the amount of memory requested is non-\/zero. Trying to allocate 0 bytes of memory is an error. Please use the explicit value {\ttfamily N\+U\+LL} in this case and handle it in your code accordingly.

If the allocated block of memory is intended to hold an array of values, you should use the alternate functions {\ttfamily x\+Realloc\+Array} and {\ttfamily x\+Realloc\+Array\+Zero} instead.

\subsection*{Working with Strings }

It is strongly encouraged to use the functions starting with {\ttfamily String\+\_\+} from {\ttfamily \hyperlink{XUtils_8h}{X\+Utils.\+h}} for working with zero-\/terminated strings as these make the A\+PI easier to use and are intended to make the intent of your code easier to grasp.

Thus instead of {\ttfamily !strcmp(foo, \char`\"{}foo\char`\"{})} it\textquotesingle{}s preferred to use {\ttfamily String\+\_\+eq(foo, \char`\"{}foo\char`\"{})} instead. While sometimes a bit more to type, this helps a lot with making the code easier to follow.

\subsection*{Styling the code }

Now for the style details that can mostly be automated\+: Indentation, spacing and bracing. While there is no definitive code style we use, a set of rules loosely enforced has evolved.

Indentation in the code is done by three (3) spaces. No tabs are used. Ever.

Before and after keywords should be a space, e.\+g. {\ttfamily if (condition)} and {\ttfamily do \{ â€¦ \} while (condition);}.

After opening and before closing braces a new line should be started. Content of such encoded blocks should be indented one level further than their enclosing block.

If a line of source code becomes too long, or when structuring it into multiple parts for clarity, the continuation line should be indented one more level than the first line it continues\+:


\begin{DoxyCode}
\textcolor{keywordflow}{if} (very\_long\_condition &&
   another\_very\_complex\_expression &&
   something\_else\_to\_check) \{
   \textcolor{comment}{// Code follows as normal ...}
\} \textcolor{keywordflow}{else} \{

\}
\end{DoxyCode}


Braces around simple single code statements (return, break, continue, goto, trivial assignments) are usually left out.


\begin{DoxyCode}
\textcolor{keywordflow}{if} (answer)
   \textcolor{keywordflow}{return} 42;
\end{DoxyCode}


If it helps readability (with several unrelated if statements in a row) or to avoid dangling-\/else situations braces can be added.

Control flow statements and the instruction making up their body should not be put on a single line, i.\+e. after the condition of an if statement a new line should be inserted and the body indented accordingly.


\begin{DoxyCode}
\textcolor{keywordflow}{if} (answer)
   \textcolor{keywordflow}{return} 42;
\textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (again)
   \textcolor{keywordflow}{continue};
\textcolor{keywordflow}{else}
   \textcolor{keywordflow}{break};
\end{DoxyCode}


When the statements that form control flow constructs are complex (e.\+g. more than just a simple assignment or jump) or need explanatory comments you should use braces. If any block of such a statement uses braces then all blocks of that statement must have braces too.


\begin{DoxyCode}
\textcolor{keywordflow}{if} ((fd = open(filename, O\_RDONLY)) >= 0 &&
   (amtRead = read(buffer, \textcolor{keyword}{sizeof}(buffer))) > 0) \{
   \textcolor{comment}{// Parse the information further ...}
   metric = handleBufferContent(buffer, amtRead);
\} \textcolor{keywordflow}{else} \{
   metric = -1;
\}

\textcolor{keywordflow}{if} (fd >= 0)
   close(fd);
\end{DoxyCode}


While the existing code base isn\textquotesingle{}t fully consistent with this code style yet it is strongly recommended that new code follows these rules. Adapting surrounding code near places you need to touch is encouraged. Try to split off such changes into a separate, clean-\/up only commit to reduce noise while reviewing your changes.

When writing your code consistency with the surrounding codebase is favoured.

Don\textquotesingle{}t shy away from leaving (single) blank lines to separate different groups of related statements. They can be a great asset to structure the flow of a method.


\begin{DoxyCode}
\textcolor{keywordtype}{int} stuff = 0;

\textcolor{comment}{// If asked for gives only half the answer ...}
\textcolor{keywordflow}{if} (param)
   stuff = 21;

\textcolor{comment}{// Compute the answer}
stuff %= 2;
stuff *= 4;
stuff *= 5;
stuff += !!stuff;
stuff *= 2;

\textcolor{keywordflow}{return} stuff;
\end{DoxyCode}


If you want to automate formatting your code, the following command gives you a good baseline of how it should look\+:


\begin{DoxyCode}
astyle -r -xb -s3 -p -xg -c -k1 -W1 -H \(\backslash\)*.c \(\backslash\)*.h
\end{DoxyCode}


\subsection*{Working with System A\+P\+Is }

Please try to be considerate when using modern platform features. While they usually provide quite a performance gain or make your life easier, it is beneficial if {\ttfamily htop} runs on rather ancient systems. Thus when you want to use such features you should try to have an alternative available that works as a fallback.

An example for this are functions like {\ttfamily fstatat} on Linux that extend the kernel A\+PI on modern systems. But even though it has been around for over a decade you are asked to provide a P\+O\+S\+IX alternative like emulating such calls by {\ttfamily fstat} if this is doable. If an alternative can not be provided you should gracefully downgrade. That could make a feature that requires this shiny A\+PI unavailable on systems that lack support for that A\+PI. Make this case visually clear to the user.

In general, code written for the project should be able to compile on any C99-\/compliant compiler.

\subsection*{Writing documentation }

The primary user documentation should be the man file which you can find in {\ttfamily htop.\+1.\+in}.

Additional documentation, like this file, should be written in gh-\/style markdown. Make each sentence one line. Markdown will combine these in output formats. It does only insert a paragraph if you insert a blank line into the source file. This way git can better diff and present the changes when documentation is altered.

Documentation files reside in the {\ttfamily docs/} directory and have a {\ttfamily .md} extension.

\subsection*{Writing pull-\/requests (P\+Rs) }

When writing your PR or patch, the set of patches should contain the minimal changes required. Each patch in itself should ideally be self-\/contained and runable. The commit comment should be descriptive ({\ttfamily Updated Foo.\+c} is not), explain what the changes are and describe why they were made. While in trivial cases a short subject suffices, more complex changes might warrant a longer description and explanation of the rationale behind the changes.

A PR should not contain any merge commits. To follow the upstream branch of your PR rebase your work instead.

Avoid small commits that just fix typos that another of your commits introduced. Instead squash those changes in the appropriate commit that introduced that mistake. Git offers {\ttfamily git commit -\/-\/fixup=$<$commit$>$} and {\ttfamily git rebase -\/i -\/-\/autosquash} to help you with this.

Your final PR should contain a minimal set of reasonably sized commits that by themselves are easy to review. If you open a PR you need to follow up to resolve any comments/change requests. Otherwise it may be closed without merging.

Rebase early. Rebase often. 